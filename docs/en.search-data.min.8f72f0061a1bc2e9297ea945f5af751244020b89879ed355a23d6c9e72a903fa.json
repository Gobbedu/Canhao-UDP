[{"id":0,"href":"/Canhao-UDP/docs/canh%C3%A3o-udp/log/","title":"Log","section":"Canhão UDP","content":"Arquivo Log #   O log criado segue os seguintes formatos:  Cliente #  Após executar egwvg20@h10:Canhao-UDP$ ./cliente h11 2000 100. Apenas indica quando houve o fim da transmissão de disparos, como no exemplo abaixo:\nIniciando envio de mensagens! Serão enviadas 100 mensagens! Todas as mensagens foram enviadas com sucesso! Servidor #  Após executar egwvg20@h11:Canhao-UDP$ ./servidor 2000 Fica em loop infinito, até que seja encerrado com Ctrl+C. Só é adicionado uma nova mensagem ao log caso:\n Houve erro na recepção da sequência da mensagem Recebeu todas as mensagens O socket que recebe dados no servidor recebeu TIMEOUT  Se ocorrer 1 ou 3, o log vai indicar quais mensagens chegaram corretamente em um intervalo:\nServidor recebeu [ X .. Y ] OK Caso ocorra 1, logo em seguida indica qual mensagem o servidor esperava e qual ele acabou recebendo. Após a inversão de sequência, a mensagem esperada pelo servidor é atualizada como sendo a próxima sequência contando partir da sequência recebida.\nServidor esperava A, recebeu B =\u0026gt; fora de sequencia, espera B+1 Ao final, é indicado a porcentagem de mensagens recebidas e perdidas.\nServidor canhao: foi recebido 100.00% do total de disparos! Servidor canhao: foi perdido 0.00% do total de disparos! Exemplo com 100 disparos #  Servidor ouvindo na porta 2000 Servidor recebeu [ 1 .. 100 ] OK Servidor canhao: Todas as mensagens foram recebidas! Servidor canhao: foi recebido 100.00% do total de disparos! Servidor canhao: foi perdido 0.00% do total de disparos! Servidor ouvindo na porta 2000 Rodada maior Servidor #  Servidor ouvindo na porta 2000 Servidor recebeu [ 1 .. 13209 ] OK Servidor esperava 13210, recebeu 13234 =\u0026gt; fora de sequencia, espera 13235 Servidor recebeu [ 13235 .. 13373 ] OK Servidor esperava 13374, recebeu 13447 =\u0026gt; fora de sequencia, espera 13448 Servidor recebeu [ 13448 .. 13586 ] OK Servidor esperava 13587, recebeu 13646 =\u0026gt; fora de sequencia, espera 13647 Servidor recebeu [ 13647 .. 13715 ] OK Servidor esperava 13716, recebeu 13797 =\u0026gt; fora de sequencia, espera 13798 Servidor recebeu [ 13798 .. 13936 ] OK . . (comentado para brevidade) . Servidor esperava 715747, recebeu 715749 =\u0026gt; fora de sequencia, espera 715750 Servidor recebeu [ 715750 .. 716028 ] OK Servidor esperava 716029, recebeu 716105 =\u0026gt; fora de sequencia, espera 716106 Servidor recebeu [ 716106 .. 722474 ] OK Servidor esperava 722475, recebeu 722480 =\u0026gt; fora de sequencia, espera 722481 Servidor recebeu [ 722481 .. 722759 ] OK Servidor esperava 722760, recebeu 722769 =\u0026gt; fora de sequencia, espera 722770 Servidor recebeu [ 722770 .. 1000000 ] OK Servidor erro timeout recv : (Resource temporarily unavailable); errno: (11) Servidor canhao: foram perdidas 21367 mensagens Servidor canhao: foi recebido 97.86% do total de disparos! Servidor canhao: foi perdido 2.13% do total de disparos! Servidor ouvindo na porta 2000 Testes de perda Consecutivos: #  Somente relatório final apontado pelo servidor\nPara 1*10^6 mensagens: (1M)\nServidor canhao: foi perdido 14.26% do total de disparos! Servidor canhao: foi perdido 7.68% do total de disparos! Servidor canhao: foi perdido 1.32% do total de disparos! Para 1*10^7 mensagens: (10M)\nServidor canhao: foi perdido 1.77% do total de disparos! Servidor canhao: foi perdido 5.31% do total de disparos! Servidor canhao: foi perdido 7.32% do total de disparos! Para 1*10^8 mensagens: (100M)\nServidor canhao: foi perdido 8.80% do total de disparos! Servidor canhao: foi perdido 8.79% do total de disparos! Servidor canhao: foi perdido 15.49% do total de disparos! Servidor canhao: foi perdido 12.31% do total de disparos! Resultado #  Utilizando as execuções acima, no calculo abaixo\n( 1e6*(14.26 + 7.68 + 1.32)/3 + 1e7*(1.77 + 5.31 + 7.32)/3 + 1e8*(8.80 + 8.79 + 15.49 + 12.31)/4 )/(1e6 + 1e7 + 1e8) Podemos estimar que: A média obtida da execução entre as máquinas h10 e h11 na rede do departamento de informatica foi de:\n 10.73%   "},{"id":1,"href":"/Canhao-UDP/docs/canh%C3%A3o-udp/canh%C3%A3o/","title":"Canhão","section":"Canhão UDP","content":"Canhão UDP #   Descrição #  Este trabalho consiste da implementação de um sistema cliente-servidor, onde o sistema irá operar sobre o protocolo de transporte UDP.\nNesta implementação, o cliente irá enviar uma quantidade significativa de dados (\u0026ldquo;canhão\u0026rdquo;) para o servidor. Ao receber os dados, o servidor irá tomar conta e analisar conforme as mensagens chegam, quais pacotes tiveram sua ordem invertida e quantos pacotes nunca chegaram.\nObjetivo #  O objetivo deste trabalho é poder medir o desempenho da rede, ao medir quantos pacotes tiveram sua ordem de chegada invertida e quantos não chegaram ao final.\nPrimeiramente, o servidor deve ser executado e deixado \u0026ldquo;rodando\u0026rdquo; antes de se executar o cliente. Ao ser executado, o servidor irá tentar obter seu endereço IP, abrir um socket e solicitar o uso da porta especificada para o sistema operacional. Em seguida, o servidor entrará em um laço infinito, onde irá receber mensagens do cliente e irá salvar no log a sequência de eventos que vão ocorrer. Caso o número de pacotes enviados seja inferior ao número de pacotes recebidos, o servidor irá enviar um mensagem de erro após 10 segundos sem receber novos pacotes.\nOs clientes iniciam em uma sequência de passos semelhante, onde irão tentar obter o endereço IP do servidor e criar um socket. Neste ponto, o sistema está pronto para iniciar o tráfego de mensagens.\nMais detalhes sobre a execução do servidor e do cliente são apresentados nestes links.\n"},{"id":2,"href":"/Canhao-UDP/docs/canh%C3%A3o-udp/cliente/","title":"Cliente","section":"Canhão UDP","content":"Cliente UDP #  O objetivo do cliente é simples, apenas execute\n./cliente \u0026lt;endereço servidor\u0026gt; \u0026lt;porta\u0026gt; \u0026lt;número de pacotes\u0026gt; Para enviar ao servidor na porta \u0026lt;porta\u0026gt; com \u0026lt;número de pacotes\u0026gt; pacotes. Estes pacotes serão enviados em ordem, de 1 a N, Cada pacote é enviado uma vez, e contém em seus dados o número da sequencia enviada e o número de pacotes totais a serem enviados.\nKernel #  A parte central de execução deste código é realçado abaixo\nlong int num_total = atol(argv[3]); // ascii to long int  printf(\u0026#34;Iniciando envio de mensagens!\\n\u0026#34;); printf(\u0026#34;Serão enviadas %ld mensagens!\\n\u0026#34;, num_total); for(long int msg = 1; msg \u0026lt;= num_total; msg++){ memset(buffer,0,BUFSIZ+1); // limpa o buffer  // transforma int msg em char *dados;  sprintf(dados, \u0026#34;%ld %ld\u0026#34;, msg, num_total); if(sendto(sockdescr, dados, strlen(dados)+1, 0, (struct sockaddr *) \u0026amp;servaddr, sizeof(servaddr)) != strlen(dados)+1) { perror(\u0026#34;Nao consegui transmitir dados\u0026#34;); exit(1); } } printf(\u0026#34;Todas as mensagens foram enviadas com sucesso!\\n\\n\u0026#34;); Fonte #  O código fonte RAW pode ser acessado aqui.  Mais informações sobre a origem do código fonte podem ser vistos na pagina home do site\n"},{"id":3,"href":"/Canhao-UDP/docs/canh%C3%A3o-udp/servidor/","title":"Servidor","section":"Canhão UDP","content":"Servidor UDP #  O objetivo do servidor é analisar as mensagens recebidas e imprimir em um log a sequência de eventos que vão ocorrer. Por exemplo, qual sequência chegou em ordem, em qual momento uma mensagem chegou fora da sequência, etc.\nO servidor deve ser executado da seguinte maneira:\n./servidor \u0026lt;porta\u0026gt; De forma que o socket ficará ouvindo em um loop infinito na porta \u0026lt;porta\u0026gt;. O socket do servidor foi configurado para retornar um erro de timeout a cada 10 segundos, função que nos auxilia a verificar se mensagens do cliente nunca chegaram, para o servidor encerrar esta análise e voltar a ouvir na porta, esperando uma nova leva de mensagens.\nO socket foi configurado da seguinte maneira para retornar timeout:\n// seta recv socket options to timeout at 10 seconds  struct timeval optval; optval.tv_sec = 10; optval.tv_usec = 0; if (setsockopt(sock_escuta, SOL_SOCKET, SO_RCVTIMEO, \u0026amp;optval, sizeof(optval)) \u0026lt; 0) { perror(\u0026#34;Nao consegui setar timeout\u0026#34;); exit(1); } Kernel #  A parte central de execução deste código é realçado abaixo, a sessão que reinicia os parâmetros para ouvir a uma nova leva de mensagem foram omitidos aqui, mas podem ser visualizados no código RAW disponibilizado no link no final desta página.\nlong int esperado = 1, // primeira mensagem esperada  num_total = -1, // numero total de mensagens  contador = 0, // contador de mensagens recebidas  recebeu; // mensagem recebida  int recebendo_sequencia = 0; // flag para log de sequencia: serv recebeu [1 .. X] OK  while(1) { unsigned int i = sizeof(clientaddr); memset(buffer, 0, BUFSIZ); // Limpa o buffer  // Recebe mensagem do cliente  int bytes = recvfrom(sock_escuta, buffer, BUFSIZ, 0, (struct sockaddr *) \u0026amp;clientaddr, \u0026amp;i); // houve erro no recv  if((bytes \u0026lt; 1) \u0026amp;\u0026amp; (errno == EAGAIN || errno == EWOULDBLOCK)){ // nao faz nada se nao iniciou canhao  if(num_total == -1) { continue; } // houve erro, encerra log com ultima mensagem recebida  printf(\u0026#34;%ld ] OK\\n\u0026#34;, esperado-1); printf(\u0026#34;Servidor erro timeout recv : (%s); errno: (%d)\\n\u0026#34;, strerror(errno), errno); break; } // Encontra o numero de sequencia na mensagem  recebeu = atol(strtok(buffer, \u0026#34; \u0026#34;)); contador++; // setar o numero total da sequencia uma vez  if(num_total == -1) { num_total = atol(strtok(NULL, \u0026#34; \u0026#34;)); } // esperava I, encontrou J =\u0026gt; fora de sequencia, espera J++  if(recebeu != esperado){ // quebrou sequencia, finaliza seq no log  if(recebendo_sequencia){ printf(\u0026#34;%ld ] OK\\n\u0026#34;, esperado-1); } // avisa que perdeu sequencia no log  printf(\u0026#34;Servidor esperava %ld, \\ recebeu %ld =\u0026gt; fora de sequencia, espera %ld\\n\u0026#34;, esperado, recebeu, recebeu+1); esperado = recebeu+1; recebendo_sequencia = 0; } // recebeu [1 ate X] OK  else if(recebeu == esperado){ // reiniciando uma sequencia  if(!recebendo_sequencia){ printf(\u0026#34;Servidor recebeu [ %ld .. \u0026#34;, recebeu); recebendo_sequencia = 1; } // no meio de sequencia, continua  esperado = recebeu+1; } if(contador == num_total) { if(recebendo_sequencia){ printf(\u0026#34;%ld ] OK\\n\u0026#34;, esperado-1); } printf(\u0026#34;Servidor canhao: Todas as mensagens foram recebidas!\\n\u0026#34;); break; } } if(contador != num_total){ printf(\u0026#34;Servidor canhao: foram perdidas %ld mensagens\\n\u0026#34;, num_total - contador); } Fonte #  O código fonte RAW pode ser acessado aqui.  Mais informações sobre a origem do código fonte podem ser vistos na pagina home do site.\n"},{"id":4,"href":"/Canhao-UDP/docs/canh%C3%A3o-udp/udp/","title":"UDP","section":"Canhão UDP","content":"User Datagram Protocol (UDP) #  O Protocolo UDP é um protocolo de comunicação utilizado em toda a internet para transmissões com validade especialmente limitada, tais como reproduções de vídeo ou pesquisas no DNS. Ele acelera as comunicações ao não estabelecer formalmente uma conexão antes que os dados sejam transferidos. Isso permite que os dados sejam transferidos muito rapidamente, mas também pode fazer com que pacotes se percam em trânsito além de criar oportunidades de exploração na forma de ataques DDoS.\nNeste site/relatório é analisado um algoritmo que testa a perda e inversão na ordem dos pacotes em uma rede utilizando este protocolo. mais detalhes podem ser visos na página canhão.\n"}]